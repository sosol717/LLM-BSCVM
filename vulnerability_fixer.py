import random
import numpy as np
from typing import Dict, Any
from dataclasses import dataclass
import logging
import torch
from transformers import AutoModelForCausalLM, AutoTokenizer
from modules.base_analyzer import BaseAnalyzer

# 设置日志详细程度
logging.basicConfig(level=logging.DEBUG)
logger = logging.getLogger(__name__)

@dataclass
class FixerResponse:
    fixed_code: str = ""
    status: str = ""
    has_fix: bool = False
    message: str = ""

class VulnerabilityFixer(BaseAnalyzer):
    def __init__(self, model_path: str, knowledge_base_path: str, seed: int = 42):
        super().__init__()
        self.device = torch.device("cuda:1" if torch.cuda.is_available() else "cpu")
        logger.info(f"Using device: {self.device}")
        
        # 设置随机种子，确保结果可重现
        self.set_seed(seed)
        
        self._initialize_model_and_tokenizer(model_path)

    def set_seed(self, seed: int):
        """设置随机种子，确保结果可复现"""
        random.seed(seed)
        np.random.seed(seed)
        torch.manual_seed(seed)
        if torch.cuda.is_available():
            torch.cuda.manual_seed_all(seed)
        logger.info(f"Random seed set to {seed}")



    def _generate_fix_prompt(self, code: str, repair_suggestions: str) -> str:
        """生成修复提示语句"""
        return f"""[INST] <<SYS>> You are a smart contract security expert. Analyze the given Solidity code containing a vulnerability and fix the vulnerability based on the provided fix recommendations. Return only the fixed Solidity code.
        <</SYS>>

        Original code:
        ```solidity
        {code}
        ```

        Fix these security issues:
        {repair_suggestions}

        Requirements:
        1. Make sure to ensure that all function names and parameters and logic of the fixed Solidity code are identical to the original Solidity code.
        2. Do not introduce new code fragments, contract functions
        3. Only return the repaired code without any interpretation or change of function structure.

        [/INST]"""

    def _evaluate_fix(self, fixed_code: str, original_code: str) -> bool:
        """评估修复后的代码是否符合要求"""
        if not self._validate_functions_exist(fixed_code, original_code):
            logger.error("The fixed code has modified or omitted the original functions.")
            return False
        return True

    def analyze(self, contract_code: str, context: Dict[str, Any] = None) -> Dict[str, Any]:
        """分析并修复合约漏洞"""
        try:
            if not self._has_valid_context(context):
                return self._create_error_response("No repair suggestions provided")

            fix_prompt = self._generate_fix_prompt(contract_code, context["repair_suggestion"])
            inputs = self._tokenize_input(fix_prompt)

            # 初步生成修复代码
            clean_code = self._generate_fixed_code(inputs)

            # 如果修复无效，循环修复，直到通过评判
            iteration = 0
            while not self._evaluate_fix(clean_code, contract_code) and iteration < 5:
                logger.info(f"Attempt {iteration + 1} failed. Attempting further fixes...")
                fix_prompt = self._generate_fix_prompt(clean_code, context["repair_suggestion"])
                inputs = self._tokenize_input(fix_prompt)
                clean_code = self._generate_fixed_code(inputs)
                iteration += 1

            # 返回修复结果
            if self._evaluate_fix(clean_code, contract_code):
                return self._create_success_response(clean_code, iteration)
            else:
                return self._create_error_response("Failed to generate a valid fix after multiple attempts")

        except Exception as e:
            logger.error(f"Error in vulnerability fixing: {str(e)}")
            return self._create_error_response(f"Error during fixing: {str(e)}")

    def _has_valid_context(self, context: Dict[str, Any]) -> bool:
        """检查上下文是否有效"""
        return context and "repair_suggestion" in context

    def _tokenize_input(self, fix_prompt: str):
        """将修复提示转换为模型输入"""
        return self.tokenizer(
            fix_prompt,
            return_tensors="pt",
            truncation=True,
            max_length=4096,
            padding=True
        ).to(self.device)

    def _generate_fixed_code(self, inputs) -> str:
        """生成修复后的代码"""
        with torch.no_grad():
            outputs = self.model.generate(
                **inputs,
                max_new_tokens=1024,
                do_sample=True,  # 启用采样
                temperature=0.1,
                top_p=0.9,
                repetition_penalty=1.2,
                pad_token_id=self.tokenizer.eos_token_id,
                eos_token_id=self.tokenizer.eos_token_id,
                num_return_sequences=1
            )
        raw_response = self.tokenizer.decode(outputs[0], skip_special_tokens=True)
        return self._clean_generated_code(raw_response)

    def _clean_generated_code(self, raw_response: str) -> str:
        """清理生成的代码"""
        try:
            if "```solidity" in raw_response:
                code = raw_response.split("```solidity")[-1].split("```")[0]
            elif "```" in raw_response:
                code = raw_response.split("```")[-2]
            else:
                code = raw_response.split("[/INST]")[-1]
            return code.strip()
        except Exception as e:
            logger.error(f"Error in cleaning code: {str(e)}")
            return raw_response.strip()

    def _create_success_response(self, clean_code: str, iteration: int) -> Dict[str, Any]:
        """生成成功响应"""
        return {
            "vulnerability_fix": FixerResponse(
                fixed_code=clean_code,
                status="success",
                has_fix=True,
                message=f"Successfully generated fix after {iteration + 1} attempts"
            ).__dict__
        }

    def _create_error_response(self, message: str) -> Dict[str, Any]:
        """生成错误响应"""
        return {
            "vulnerability_fix": FixerResponse(
                status="error",
                message=message,
                has_fix=False
            ).__dict__
        }

    def _validate_functions_exist(self, fixed_code: str, original_code: str) -> bool:
        """检查修复后的代码是否完全保留原始代码中的函数签名、参数和名称"""
        import re
        original_funcs = set(re.findall(r'function\s+(\w+)\s*\((.*?)\)\s*{', original_code))
        fixed_funcs = set(re.findall(r'function\s+(\w+)\s*\((.*?)\)\s*{', fixed_code))

        missing_funcs = original_funcs - fixed_funcs
        if missing_funcs:
            for func_name, params in missing_funcs:
                logger.error(f"Missing or altered function: {func_name} with params {params}")
            return False
        return True

    def __del__(self):
        """析构函数，清理资源"""
        if hasattr(self, 'model'):
            del self.model
        if hasattr(self, 'tokenizer'):
            del self.tokenizer
        if torch.cuda.is_available():
            torch.cuda.empty_cache()



